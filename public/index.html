<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RugGenesis NFT Claim Checker</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background-color: #f8f9fa;
      color: #212529;
    }
    .container {
      max-width: 1200px;
      padding: 2rem;
    }
    .card {
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
    }
    .card-header {
      background-color: #f1f3f5;
      border-bottom: 1px solid #e9ecef;
      font-weight: 600;
    }
    .btn-primary {
      background-color: #5046e5;
      border-color: #5046e5;
    }
    .btn-primary:hover {
      background-color: #4038c2;
      border-color: #4038c2;
    }
    .table {
      font-size: 0.95rem;
    }
    .table th {
      font-weight: 600;
      color: #495057;
    }
    .positive-value {
      color: #198754;
      font-weight: 600;
    }
    .negative-value {
      color: #dc3545;
      font-weight: 600;
    }
    .spinner-border {
      width: 1.5rem;
      height: 1.5rem;
    }
    .header-logo {
      max-height: 40px;
      margin-right: 10px;
    }
    .info-box {
      background-color: #e9f5fe;
      border-left: 4px solid #0d6efd;
      padding: 1rem;
      margin-bottom: 1rem;
      border-radius: 4px;
    }
    .sortable {
      cursor: pointer;
      user-select: none;
      position: relative;
    }
    .sortable:hover {
      background-color: #f1f3f5;
    }
    .sort-icon {
      display: inline-block;
      margin-left: 4px;
      font-size: 0.9em;
    }
    #loadingIndicator {
      text-align: center;
      padding: 20px;
      display: none;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="d-flex align-items-center mb-4">
      <h1 class="mb-0">RugGenesis NFT Claim Checker</h1>
    </div>
    
    <div class="card mb-4">
      <div class="card-header">
        Check Claimable RUG Tokens
      </div>
      <div class="card-body">
        <div class="info-box mb-3">
          <p class="mb-0">This tool checks OpenSea listings for RugGenesis NFTs and calculates their claimable RUG token value. Results are sorted by net value (claimable value plus potential NFT resale at floor price minus listing price).</p>
        </div>
        
        <div class="row">
          <div class="col-md-6">
            <button id="checkListingsBtn" class="btn btn-primary">
              <span id="btnSpinner" class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
              Check OpenSea Listings
            </button>
          </div>
          <div class="col-md-6">
            <div class="input-group">
              <input type="number" id="tokenIdInput" class="form-control" placeholder="Enter Token ID">
              <button id="checkTokenBtn" class="btn btn-outline-primary">Check Token</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div id="priceInfo" class="alert alert-info d-none">
      Loading price information...
    </div>
    
    <div id="resultsDiv" class="card mb-4 d-none">
      <div class="card-header d-flex justify-content-between align-items-center">
        <span>Results</span>
        <span id="sortIndicator" class="badge bg-secondary d-none"></span>
      </div>
      <div class="card-body">
        <p>Click "Check OpenSea Listings" to view NFTs with claimable RUG tokens. Click on any column header to sort.</p>
      </div>
      <div class="card-footer text-center d-none" id="loadMoreFooter">
        <button id="manualLoadMoreBtn" class="btn btn-outline-primary btn-sm">Load More Listings</button>
      </div>
    </div>
    
    <div id="loadingIndicator">
      <div class="spinner-border text-primary" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
      <div>Loading more listings...</div>
    </div>
    
    <!-- Debug controls (hidden in production) -->
    <div id="debugControls" class="fixed-bottom bg-light p-2 border-top" style="display: none;">
      <div class="container">
        <div class="row">
          <div class="col-12">
            <button id="debugLoadMoreBtn" class="btn btn-sm btn-warning">Debug: Load More</button>
            <button id="debugCheckStateBtn" class="btn btn-sm btn-info ms-2">Debug: Check State</button>
            <span id="debugStatus" class="ms-2"></span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const checkListingsBtn = document.getElementById('checkListingsBtn');
      const checkTokenBtn = document.getElementById('checkTokenBtn');
      const tokenIdInput = document.getElementById('tokenIdInput');
      const resultsDiv = document.getElementById('resultsDiv');
      const priceInfoDiv = document.getElementById('priceInfo');
      const btnSpinner = document.querySelector('#checkListingsBtn .spinner-border');
      const manualLoadMoreBtn = document.getElementById('manualLoadMoreBtn');
      
      // Add event listener for manual load more button
      if (manualLoadMoreBtn) {
        manualLoadMoreBtn.addEventListener('click', function() {
          console.log('Manual load more button clicked');
          loadMoreListings();
        });
      }
      const loadingIndicator = document.getElementById('loadingIndicator');
      
      // Pagination and sorting state
      let currentPage = 0;
      let hasMoreListings = false;
      let allListings = [];
      let isLoading = false;
      let currentSort = { field: 'netValueUsd', direction: 'desc' }; // Default sort by net value desc
      
      // Format currency
      function formatCurrency(value) {
        if (value === undefined || value === null || isNaN(value)) {
          return '$0.00';
        }
        return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value);
      }
      
      // Format token amount
      function formatTokenAmount(amount) {
        if (amount === undefined || amount === null || isNaN(amount)) {
          return '0';
        }
        
        const amountValue = parseFloat(amount);
        // Return the integer part only (floor value)
        return Math.floor(amountValue);
      }
      
      // Sort listings
      function sortListings(listings, field, direction) {
        return [...listings].sort((a, b) => {
          let valueA = a[field];
          let valueB = b[field];
          
          // Convert to numbers if possible
          if (!isNaN(parseFloat(valueA)) && !isNaN(parseFloat(valueB))) {
            valueA = parseFloat(valueA);
            valueB = parseFloat(valueB);
          }
          
          if (valueA < valueB) return direction === 'asc' ? -1 : 1;
          if (valueA > valueB) return direction === 'asc' ? 1 : -1;
          return 0;
        });
      }
      
      // Dedupe listings by tokenId (keep the one with the higher net value)
      function dedupeByTokenId(list) {
        const map = new Map();
        for (const item of list || []) {
          if (!item || !item.tokenId) continue;
          const existing = map.get(item.tokenId);
          if (!existing) {
            map.set(item.tokenId, item);
          } else {
            const existingNet = parseFloat(existing.netValueUsd || '0');
            const currentNet = parseFloat(item.netValueUsd || '0');
            map.set(item.tokenId, currentNet >= existingNet ? item : existing);
          }
        }
        return Array.from(map.values());
      }
      
      // Update table with sorted data
      function updateTableWithSort() {
        const sortedListings = sortListings(allListings, currentSort.field, currentSort.direction);
        const tableBody = document.getElementById('listingsTableBody');
        
        if (!tableBody) return;
        
        // Clear current table
        tableBody.innerHTML = '';
        
        // Add sorted rows
        sortedListings.forEach(listing => {
          const netValueClass = parseFloat(listing.netValueUsd) > 0 ? 'positive-value' : 'negative-value';
          
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${listing.tokenId}</td>
            <td>${listing.priceEth}</td>
            <td>${formatCurrency(listing.priceUsd)}</td>
            <td>${Math.floor(parseFloat(listing.claimableAmount))}</td>
            <td>${formatCurrency(listing.claimableValueUsd)}</td>
            <td>${listing.potentialSalePriceEth}</td>
            <td>${formatCurrency(listing.potentialSalePriceUsd)}</td>
            <td class="${netValueClass}">${formatCurrency(listing.netValueUsd)}</td>
            <td>
              <a href="${listing.openseaUrl}" target="_blank" class="btn btn-sm btn-outline-primary">View</a>
            </td>
          `;
          
          tableBody.appendChild(row);
        });
        
        // Update sort indicator
        updateSortIndicator();
      }
      
      // Update sort indicator in UI
      function updateSortIndicator() {
        const indicator = document.getElementById('sortIndicator');
        if (!indicator) return;
        
        const sortableFields = {
          'tokenId': 'Token ID',
          'priceEth': 'Price (ETH)',
          'priceUsd': 'Price (USD)',
          'claimableAmount': 'Claimable',
          'claimableValueUsd': 'Claim Value',
          'potentialSalePriceEth': 'Floor (ETH)',
          'potentialSalePriceUsd': 'Floor (USD)',
          'netValueUsd': 'Net Value'
        };
        
        indicator.textContent = `Sorted by: ${sortableFields[currentSort.field]} (${currentSort.direction === 'asc' ? '↑' : '↓'})`;
        indicator.classList.remove('d-none');
        
        // Update sort icons
        document.querySelectorAll('.sort-icon').forEach(icon => {
          icon.textContent = '↕️';
        });
        
        const activeHeader = document.querySelector(`th[data-sort="${currentSort.field}"]`);
        if (activeHeader) {
          const icon = activeHeader.querySelector('.sort-icon');
          if (icon) {
            icon.textContent = currentSort.direction === 'asc' ? '↑' : '↓';
          }
        }
      }
      
      // Handle sort when clicking on headers
      function setupSortableHeaders() {
        console.log('Setting up sortable headers');
        const headers = document.querySelectorAll('.sortable');
        console.log('Found sortable headers:', headers.length);
        
        headers.forEach(header => {
          // Remove any existing event listeners to prevent duplicates
          const newHeader = header.cloneNode(true);
          header.parentNode.replaceChild(newHeader, header);
          
          newHeader.addEventListener('click', function() {
            console.log('Header clicked:', this.getAttribute('data-sort'));
            const field = this.getAttribute('data-sort');
            if (!field) return;
            
            if (currentSort.field === field) {
              // Toggle direction if same field
              currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
              // New field, default to descending
              currentSort.field = field;
              currentSort.direction = 'desc';
            }
            
            updateTableWithSort();
          });
        });
      }
      
      // Function to load all listings at once
      async function loadMoreListings() {
        console.log('loadMoreListings called');
        if (isLoading) {
          console.log('Already loading, ignoring request');
          return;
        }
        
        isLoading = true;
        const loadingIndicator = document.getElementById('loadingIndicator');
        if (loadingIndicator) loadingIndicator.style.display = 'block';
        console.log('Loading all listings at once');
        
        try {
          const response = await fetch('/check-listings');
          
          if (!response.ok) {
            throw new Error(`API error: ${response.status} ${response.statusText}`);
          }
          
          const data = await response.json();
          console.log('Received data:', data);
          
          // No more pagination since we're loading all at once
          hasMoreListings = false;
          console.log('hasMoreListings set to false - all listings loaded at once');
          
          // Ensure listings is an array
          const newListings = Array.isArray(data.listings) ? data.listings : [];
          console.log('Total listings count:', newListings.length);
          
          if (newListings.length > 0) {
            // Add new listings to the table
            const tableBody = document.getElementById('listingsTableBody');
            if (!tableBody) {
              console.error('listingsTableBody element not found!');
              return;
            }
            
            newListings.forEach(listing => {
              const netValueClass = parseFloat(listing.netValueUsd) > 0 ? 'positive-value' : 'negative-value';
              
              const row = document.createElement('tr');
              row.innerHTML = `
                <td>${listing.tokenId}</td>
                <td>${listing.priceEth}</td>
                <td>${formatCurrency(listing.priceUsd)}</td>
                <td>${Math.floor(parseFloat(listing.claimableAmount))}</td>
                <td>${formatCurrency(listing.claimableValueUsd)}</td>
                <td>${listing.potentialSalePriceEth}</td>
                <td>${formatCurrency(listing.potentialSalePriceUsd)}</td>
                <td class="${netValueClass}">${formatCurrency(listing.netValueUsd)}</td>
                <td>
                  <a href="${listing.openseaUrl}" target="_blank" class="btn btn-sm btn-outline-primary">View</a>
                </td>
              `;
              
              tableBody.appendChild(row);
            });
            
            // Add new listings to our stored array, then dedupe and sort them
            allListings = allListings.concat(newListings);
            allListings = dedupeByTokenId(allListings);
            console.log('Total listings loaded:', allListings.length);
            
            // Update table with sorted data
            updateTableWithSort();
            
            // Setup sortable headers after table is created
            setupSortableHeaders();
          }
          
          // If no more listings, remove scroll event listener
          if (!hasMoreListings) {
            console.log('No more listings available, removing scroll listener');
            window.removeEventListener('scroll', handleScroll);
          }
        } catch (error) {
          console.error('Error loading more listings:', error);
          const errorDiv = document.createElement('div');
          errorDiv.className = 'alert alert-danger mt-3';
          errorDiv.textContent = `Error loading more listings: ${error.message || 'Unknown error'}. Please try again.`;
          resultsDiv.querySelector('.card-body').appendChild(errorDiv);
          
          // Remove scroll event listener on error
          window.removeEventListener('scroll', throttledHandleScroll);
        } finally {
          isLoading = false;
          const loadingIndicator = document.getElementById('loadingIndicator');
          if (loadingIndicator) loadingIndicator.style.display = 'none';
          console.log('Loading completed, isLoading set to false');
        }
      }
      
      // Throttle function to limit how often a function can be called
      function throttle(func, limit) {
        let inThrottle;
        return function() {
          const args = arguments;
          const context = this;
          if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
          }
        };
      }
      
      // Handle scroll event for infinite scrolling
      function handleScroll() {
        console.log('Scroll event triggered');
        if (isLoading) {
          console.log('Ignoring scroll - currently loading');
          return;
        }
        if (!hasMoreListings) {
          console.log('Ignoring scroll - no more listings available');
          return;
        }
        
        const scrollHeight = document.documentElement.scrollHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        const clientHeight = document.documentElement.clientHeight;
        
        console.log('Scroll position:', scrollTop + clientHeight, 'of', scrollHeight, '(threshold:', scrollHeight - 300, ')');
        
        // Load more when user scrolls to bottom (with 300px threshold)
        if (scrollTop + clientHeight >= scrollHeight - 300) {
          console.log('Loading more listings from scroll event');
          loadMoreListings();
        } else {
          console.log('Not close enough to bottom yet');
        }
      }
      
      // Create throttled version of scroll handler
      const throttledHandleScroll = throttle(handleScroll, 200);
      
      // Check listings
      checkListingsBtn.addEventListener('click', async function() {
        // Reset state for loading all listings at once
        allListings = [];
        isLoading = false;
        
        // Make sure the results div is visible
        resultsDiv.classList.remove('d-none');
        
        // Debug helper to manually load more listings
        window.debugLoadMore = function() {
          console.log('Manual debug load more triggered');
          loadMoreListings();
          return 'Loading more listings...'; 
        };
        
        // Debug helper to check state
        window.checkScrollState = function() {
          const scrollHeight = document.documentElement.scrollHeight;
          const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
          const clientHeight = document.documentElement.clientHeight;
          const state = {
            scrollHeight,
            scrollTop,
            clientHeight,
            position: scrollTop + clientHeight,
            threshold: scrollHeight - 300,
            shouldLoad: scrollTop + clientHeight >= scrollHeight - 300,
            isLoading,
            hasMoreListings,
            currentPage
          };
          console.log('DEBUG - Scroll state:', state);
          return state;
        };
        
        // Remove scroll event listener if it exists
        window.removeEventListener('scroll', throttledHandleScroll);
        
        // Show loading state
        btnSpinner.classList.remove('d-none');
        checkListingsBtn.disabled = true;
        resultsDiv.querySelector('.card-body').innerHTML = '<p>Loading listings... This may take a minute.</p>';
        
        try {
          const response = await fetch('/check-listings');
          
          if (!response.ok) {
            throw new Error(`API error: ${response.status} ${response.statusText}`);
          }
          
          const data = await response.json();
          
          // Debug the API response
          console.log('API Response:', data);
          
          // Store pagination info
          currentPage = data.page || 0;
          hasMoreListings = data.hasMore || false;
          
          // Check if data has the expected structure
          if (!data) {
            throw new Error('Invalid response from server');
          }
          
          // Update price info
          priceInfoDiv.classList.remove('d-none');
          priceInfoDiv.innerHTML = `
            <strong>Current Prices:</strong> ETH: ${formatCurrency(data.ethPrice || 0)} | 
            RUG Token: ${formatCurrency(data.rugPrice || 0)} | 
            Last Updated: ${new Date(data.timestamp || Date.now()).toLocaleTimeString()}
          `;
          
          // Get listings from the response and dedupe by tokenId
          const listings = Array.isArray(data.listings) ? data.listings : [];
          const uniqueListings = dedupeByTokenId(listings);
          console.log(`Displaying ${uniqueListings.length} listings (deduped from ${listings.length})`);
          
          // Store all listings
          allListings = uniqueListings;
          
          // Create results HTML
          let resultsHtml = '';
          
          if (listings.length === 0) {
            resultsHtml = '<div class="alert alert-info">No listings with claimable RUG tokens found.</div>';
          } else {
            resultsHtml = `
              <div class="table-responsive">
                <table class="table table-striped table-hover">
                  <thead>
                    <tr>
                      <th class="sortable" data-sort="tokenId">Token ID <span class="sort-icon">↕️</span></th>
                      <th class="sortable" data-sort="priceEth">Price (ETH) <span class="sort-icon">↕️</span></th>
                      <th class="sortable" data-sort="priceUsd">Price (USD) <span class="sort-icon">↕️</span></th>
                      <th class="sortable" data-sort="claimableAmount">Claimable RUG <span class="sort-icon">↕️</span></th>
                      <th class="sortable" data-sort="claimableValueUsd">Claimable Value <span class="sort-icon">↕️</span></th>
                      <th class="sortable" data-sort="potentialSalePriceEth">Potential Sale Price (ETH) <span class="sort-icon">↕️</span></th>
                      <th class="sortable" data-sort="potentialSalePriceUsd">Potential Sale Price (USD) <span class="sort-icon">↕️</span></th>
                      <th class="sortable" data-sort="netValueUsd">Net Value <span class="sort-icon">↕️</span></th>
                      <th>Action</th>
                    </tr>
                  </thead>
                  <tbody id="listingsTableBody">
            `;
            
            uniqueListings.forEach(listing => {
              const netValueClass = parseFloat(listing.netValueUsd) > 0 ? 'positive-value' : 'negative-value';
              
              resultsHtml += `
                <tr>
                  <td>${listing.tokenId}</td>
                  <td>${listing.priceEth}</td>
                  <td>${formatCurrency(listing.priceUsd)}</td>
                  <td>${Math.floor(parseFloat(listing.claimableAmount))}</td>
                  <td>${formatCurrency(listing.claimableValueUsd)}</td>
                  <td>${listing.potentialSalePriceEth}</td>
                  <td>${formatCurrency(listing.potentialSalePriceUsd)}</td>
                  <td class="${netValueClass}">${formatCurrency(listing.netValueUsd)}</td>
                  <td>
                    <a href="${listing.openseaUrl}" target="_blank" class="btn btn-sm btn-outline-primary">View</a>
                  </td>
                </tr>
              `;
            });
            
            resultsHtml += '</tbody></table></div>';
          }
          
          resultsDiv.querySelector('.card-body').innerHTML = resultsHtml;
          
          // Setup sortable headers after table is created
          setupSortableHeaders();
          
          // Show or hide the manual load more button
          const loadMoreFooter = document.getElementById('loadMoreFooter');
          if (hasMoreListings) {
            loadMoreFooter.classList.remove('d-none');
          } else {
            loadMoreFooter.classList.add('d-none');
          }
          
          // Make sure the results div is visible
          resultsDiv.classList.remove('d-none');
          
          // No need for scroll event listeners since we're loading all listings at once
          console.log('Loading all listings at once - no infinite scroll needed');
          window.removeEventListener('scroll', throttledHandleScroll);
        } catch (error) {
          console.error('Error:', error);
          priceInfoDiv.classList.remove('d-none');
          priceInfoDiv.innerHTML = `<strong>Error:</strong> Could not fetch price data`;
          resultsDiv.querySelector('.card-body').innerHTML = `<div class="alert alert-danger">Error fetching data: ${error.message || 'Unknown error'}. Please try again.</div>`;
        } finally {
          // Reset button state
          btnSpinner.classList.add('d-none');
          checkListingsBtn.disabled = false;
        }
      });
      
      // Check specific token
      checkTokenBtn.addEventListener('click', async function() {
        const tokenId = tokenIdInput.value.trim();
        
        if (!tokenId) {
          alert('Please enter a token ID');
          return;
        }
        
        // Show loading state
        resultsDiv.querySelector('.card-body').innerHTML = '<p>Checking token ' + tokenId + '...</p>';
        
        try {
          const response = await fetch(`/check-token/${tokenId}`);
          
          if (!response.ok) {
            throw new Error(`API error: ${response.status} ${response.statusText}`);
          }
          
          const data = await response.json();
          
          if (!data || data.error) {
            throw new Error(data.message || 'Invalid response from server');
          }
          
          // Update price info
          priceInfoDiv.classList.remove('d-none');
          priceInfoDiv.innerHTML = `
            <strong>Current Prices:</strong> RUG Token: ${formatCurrency(data.rugPrice || 0)} | 
            Last Updated: ${new Date(data.timestamp || Date.now()).toLocaleTimeString()}
          `;
          
          // Update results
          const resultsHtml = `
            <div class="card">
              <div class="card-header">Token #${data.tokenId} Details</div>
              <div class="card-body">
                <div class="row">
                  <div class="col-md-6">
                    <p><strong>Claimable RUG Tokens:</strong> ${Math.floor(parseFloat(data.claimableAmount || 0))}</p>
                    <p><strong>Claimable Value:</strong> ${formatCurrency(data.claimableValueUsd || 0)}</p>
                    <p><strong>Potential Sale Price:</strong> ${data.potentialSalePriceEth || '0.0900'} ETH (${formatCurrency(data.potentialSalePriceUsd || 0)})</p>
                  </div>
                  <div class="col-md-6">
                    <a href="https://opensea.io/assets/ethereum/0x8ff1523091c9517bc328223d50b52ef450200339/${data.tokenId}" 
                       target="_blank" class="btn btn-outline-primary">View on OpenSea</a>
                  </div>
                </div>
              </div>
            </div>
          `;
          
          resultsDiv.querySelector('.card-body').innerHTML = resultsHtml;
          
          // Setup sortable headers after table is created
          setupSortableHeaders();
          
          // Remove scroll event listener when viewing a specific token
          window.removeEventListener('scroll', handleScroll);
        } catch (error) {
          console.error('Error:', error);
          priceInfoDiv.classList.remove('d-none');
          priceInfoDiv.innerHTML = `<strong>Error:</strong> Could not fetch token data`;
          resultsDiv.querySelector('.card-body').innerHTML = `<div class="alert alert-danger">Error checking token: ${error.message || 'Unknown error'}. Please try again.</div>`;
        }
      });
    });
  </script>
</body>
</html>
